#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author：zenghui time:2020/12/29

#!/usr/bin/env python
# -*- coding: utf-8 -*-
# author：zenghui time:2020/9/3
import Augmentor
from PIL import Image
import random
import os
from tqdm import tqdm
from concurrent.futures import ThreadPoolExecutor
import copy
from torchvision import transforms
import numpy as np
import math
from simulation_data_generation import Pipeline_speckle
import torch
from parameter_estimation import *
from utils import *
from Augmentor.Operations import Crop
from Unet_for_pattern_detection import generate_sinusoidal_SIMdata_and_pattern_pairs
from Unet_for_pattern_detection import Pipeline_SIMdata_pattern_pairs
import matplotlib.pyplot as plt
from parameter_estimation import test_of_estimating_m_of_various_photon_level
from simulation_data_generation import fuctions_for_generate_pattern as funcs
from parameter_estimation.estimate_polarizaion import *


class Pipeline_SIMdata_absorption_efficiency_pairs(test_of_estimating_m_of_various_photon_level.Pipeline_SIMdata_pattern_pairs):

    def __init__(self, source_directory=None, output_directory="output", image_size=256, save_format=None):
        super(Pipeline_SIMdata_absorption_efficiency_pairs, self).__init__(source_directory=source_directory, output_directory=output_directory, image_size=image_size, save_format=save_format)

    def sample(self, n, multi_threaded=True, data_type='train', data_num=16):
        """
        Generate :attr:`n` number of samples from the current pipeline.

        This function samples from the pipeline, using the original images
        defined during instantiation. All images generated by the pipeline
        are by default stored in an ``output`` directory, relative to the
        path defined during the pipeline's instantiation.

        By default, Augmentor will use multi-threading to increase the speed
        of processing the images. However, this may slow down some
        operations if the images are very small. Set :attr:`multi_threaded`
        to ``False`` if slowdown is experienced.

        :param n: The number of new samples to produce.
        :type n: Integer
        :param multi_threaded: Whether to use multi-threading to process the
         images. Defaults to ``True``.
        :type multi_threaded: Boolean
        :return: None
        """
        augmentor_images = list(range(n))
        self.data_num = data_num
        self.data_type = data_type


        if self.data_type == 'train':
            self.txt_directory = self.train_txt_directory
        elif self.data_type == 'valid':
            self.txt_directory = self.valid_txt_directory
        else:
            raise Exception("error data_type")

        if len(self.augmentor_images) == 0:
            raise IndexError("There are no images in the pipeline. "
                             "Add a directory using add_directory(), "
                             "pointing it to a directory containing images.")

        total_estimated_modulation_factor = []
        total_GT_modulation_factor = []
        MSE_loss = nn.MSELoss()
        total_mse_loss = torch.zeros(1)
        total_mse_loss_regression = torch.zeros(1)
        if n == 0:
            augmentor_images = self.augmentor_images
        else:
            for i in range(n):
                augmentor_images[i] = copy.deepcopy(random.choice(self.augmentor_images))

        if multi_threaded:
            # TODO: Restore the functionality (appearance of progress bar) from the pre-multi-thread code above.
            with tqdm(total=len(augmentor_images), desc="Executing Pipeline", unit=" Samples") as progress_bar:
                with ThreadPoolExecutor(max_workers=None) as executor:
                    for result in executor.map(self, augmentor_images):
                        progress_bar.set_description("Processing %s" % result)
                        progress_bar.update(1)
        else:
            with tqdm(total=len(augmentor_images), desc="Executing Pipeline", unit=" Samples") as progress_bar:
                for augmentor_image in augmentor_images:
                    estimated_absorption_efficiency,estimated_absorption_efficiency_regression,GT_absorption_efficiency = self._execute(augmentor_image)
                    mse_loss = MSE_loss(estimated_absorption_efficiency/estimated_absorption_efficiency.max(), GT_absorption_efficiency/GT_absorption_efficiency.max())
                    total_mse_loss += mse_loss
                    mse_loss = MSE_loss(estimated_absorption_efficiency_regression/estimated_absorption_efficiency_regression.max(), GT_absorption_efficiency/GT_absorption_efficiency.max())
                    total_mse_loss_regression += mse_loss
                    # total_estimated_modulation_factor.append(estimated_modulation_factor)
                    # total_GT_modulation_factor.append(GT_modulation_factor)
                    progress_bar.set_description("Processing %s" % os.path.basename(augmentor_image.image_path))
                    progress_bar.update(1)

        even_mse_loss = total_mse_loss / sample_num_train
        even_mse_loss_regression = total_mse_loss_regression / sample_num_train

        # print(total_estimated_modulation_factor)
        # print(total_GT_modulation_factor)
        # torch.save(total_estimated_modulation_factor,SaveFileDirectory + '/even_estimated_modulation_factor')
        # torch.save(total_GT_modulation_factor, SaveFileDirectory + '/even_GT_modulation_factor')
        print('total_mse_loss:%f,even_mse_loss:%f'%(total_mse_loss,even_mse_loss))
        print('regression： total_mse_loss:%f,even_mse_loss:%f' % (total_mse_loss_regression, even_mse_loss_regression))
    def _execute(self, augmentor_image,save_to_disk=True, multi_threaded=True,):
        """
        Private method. Used to pass an image through the current pipeline,
        and return the SIM images, and  write image directories, wave vectors, phi into a json file  .

        The returned image can then either be saved to disk or simply passed
        back to the user. Currently this is fixed to True, as Augmentor
        has only been implemented to save to disk at present.

        :param augmentor_image: The image to pass through the pipeline.
        :param save_to_disk: Whether to save the image to disk. Currently
         fixed to true.
        :type augmentor_image: :class:`ImageUtilities.AugmentorImage`
        :type save_to_disk: Boolean
        :return: The augmented image.
        """

        images = []

        if augmentor_image.image_path is not None:
            images.append(Image.open(augmentor_image.image_path))

        # What if they are array data?
        if augmentor_image.pil_images is not None:
            images.append(augmentor_image.pil_images)

        if augmentor_image.ground_truth is not None:
            if isinstance(augmentor_image.ground_truth, list):
                for image in augmentor_image.ground_truth:
                    images.append(Image.open(image))
            else:
                images.append(Image.open(augmentor_image.ground_truth))


        try:
            SIM_images,GT_absorption_efficiency = self.perform_operation(images[0])

            image_size = [SIM_images.size()[1], SIM_images.size()[2]]
            experimental_params = funcs.SinusoidalPattern(probability=1, image_size=image_size[0])
            estimated_absorption_efficiency = calculate_polarization_ratio(SIM_images.unsqueeze(0), experimental_params)
            # estimated_absorption_efficiency1 = calculate_polarization_ratio(SIM_images.unsqueeze(0), experimental_params,deconv=False)
            estimated_absorption_efficiency_regression = calculate_polarization_ratio_regression(SIM_images.unsqueeze(0), experimental_params)

        except IOError as e:
            print("Error writing %s, %s. Change save_format to PNG?" % ('LR', e.message))
            print("You can change the save format using the set_save_format(save_format) function.")
            print("By passing save_format=\"auto\", Augmentor can save in the correct format automatically.")


        return estimated_absorption_efficiency,estimated_absorption_efficiency_regression,GT_absorption_efficiency.unsqueeze(0)

    def perform_operation(self, image):
        """
        Crop the passed :attr:`images` by percentage area, returning the crop as an
        image.

        :param images: The image(s) to crop an area from.
        :type images: List containing PIL.Image object(s).
        :return: The transformed image(s) as a list of object(s) of type
         PIL.Image.
        """
        crop_size=self.image_size
        h, w = image.size
        pad_w = max(crop_size - w, 0)
        pad_h = max(crop_size - h, 0)
        img_pad = transforms.Pad(padding=(0, 0, pad_w, pad_h), fill=0, padding_mode='constant')(image)
        center_crop = transforms.CenterCrop(size=(crop_size, crop_size))
        imag_pad_crop = center_crop(img_pad)

        # augmented_images += self.LR_image_generator(imag_pad_crop)
        image_gray = imag_pad_crop.convert('L')
        TensorImage = transforms.ToTensor()(image_gray)

        SIM_images,absorption_efficiency = self.SinusoidalPattern(TensorImage)

        return SIM_images,absorption_efficiency

    def SinusoidalPattern(self, image):
        '''
        :param image:  PIL_Image that will be loaded pattern on
        :param NumPhase:  Number of phase
        :return: SinusoidalPatternImage: Image which loaded sinusoidal pattern
        '''
        resolution = 0.61 * self.EmWaveLength / self.NA
        # xx, yy, _, _ = self.GridGenerate(image=torch.rand(7, 7))
        # xx, yy, fx, fy = self.GridGenerate(image)
        SinPatternPIL_Image = []
        SIMdata_Image = torch.zeros([3*self.NumPhase,self.image_size,self.image_size])
        random_initial_direction_phase = random.random() * 2 * math.pi
        absorption_efficiency = torch.zeros([3*self.NumPhase,self.image_size,self.image_size])
        # random_initial_direction_phase = 1/12  * math.pi
        for i in range(3):
            modulation_factor = random.random() / 2 + 0.5
            # modulation_factor = 0.05
            theta = i * 2 / 3 * math.pi + random_initial_direction_phase
            SpatialFrequencyX = self.pattern_frequency_ratio * 1 / resolution * math.sin(
                theta)  # 0.8倍的极限频率条纹 pattern_frequency_ratio，可调
            SpatialFrequencyY = self.pattern_frequency_ratio * 1 / resolution * math.cos(theta)
            # random_initial_phase = 1 / 4 * math.pi
            random_initial_phase = random.random() * 2 * math.pi
            for j in range(self.NumPhase):
                phase = j * 2 * math.pi / self.NumPhase + random_initial_phase
                SIMdata_OTF_filter_gaussian_noise, SinPattern_PIL,absorption_efficiency[i*self.NumPhase+j,:,: ] = self.generate_single_polarization_SIM_data(image,
                                                                                                      SpatialFrequencyX,
                                                                                                      SpatialFrequencyY,
                                                                                                      modulation_factor,
                                                                                                      phase,theta)

                SIMdata_Image[i*self.NumPhase+j,:,: ] = SIMdata_OTF_filter_gaussian_noise
                SinPatternPIL_Image.append(SinPattern_PIL)


        return SIMdata_Image, absorption_efficiency

    def generate_single_polarization_SIM_data(self,image,SpatialFrequencyX,SpatialFrequencyY,modulation_factor,phase,theta):
        xx, yy,_,_ = self.GridGenerate(up_sample= self.upsample, grid_mode='real')
        SinPattern = (torch.cos(
            phase + 2 * math.pi * (
                    SpatialFrequencyX * xx + SpatialFrequencyY * yy)) * modulation_factor + 1) / 2
        polarization_angle = torch.atan2(yy,xx)
        # polarization_angle = torch.rand_like(xx)
        absorption_efficiency = 1 - 0.4 * torch.cos(2* (theta-polarization_angle))
        OTF = self.OTF
        SIMdata_OTF_filter = self.OTF_Filter(SinPattern * image * absorption_efficiency, OTF)
        SIMdata_OTF_filter_gaussian_noise = self.add_gaussian_noise(SIMdata_OTF_filter)
        SIMdata_OTF_filter_gaussian_noise = SIMdata_OTF_filter_gaussian_noise.float()
        SIMdata_OTF_filter_gaussian_noise_PIL = transforms.ToPILImage()(
        SIMdata_OTF_filter_gaussian_noise).convert('RGB')
        SinPattern = SinPattern.float()
        SinPattern_PIL = transforms.ToPILImage()(SinPattern).convert('RGB')
        absorption_efficiency_PIL = transforms.ToPILImage()(absorption_efficiency).convert('RGB')
        polarization_angle_PIL = transforms.ToPILImage()(polarization_angle + polarization_angle.min()).convert('RGB')


        return SIMdata_OTF_filter_gaussian_noise, absorption_efficiency_PIL, absorption_efficiency

    def add_gaussian_noise(self, tensor_Image):  # The type of input image is PIL
        # if len(TensorImage)==3:
        #      TensorImage = TensorImage.permute(1, 2, 0) # transope for matplot
        # signal_intensity_of_image = (tensor_Image ** 2).mean()  # The mean intensity of signal
        signal_std_of_image = tensor_Image.std()  # The std intensity of signal
        noise_std_of_image = signal_std_of_image / self.SNR
        noise_of_image = torch.zeros_like(tensor_Image)
        # std_of_noise = noise_std_of_image ** (0.5)
        noise_of_image.normal_(mean=0, std=noise_std_of_image)
        image_with_noise = tensor_Image + noise_of_image
        image_with_noise = torch.where(image_with_noise < 0, torch.zeros_like(image_with_noise), image_with_noise)
        image_with_noise_normalized = image_with_noise / image_with_noise.max()
        return image_with_noise_normalized
        # return image_with_noise_normalized
if __name__ == '__main__':
    data_generation_parameters = load_configuration_parameters.load_data_generation_config_paras()

    SourceFileDirectory = data_generation_parameters['SourceFileDirectory']
    SaveFileDirectory = data_generation_parameters['save_file_directory']

    EmWaveLength = data_generation_parameters['EmWaveLength']
    NA = data_generation_parameters['NA']

    train_directory = SourceFileDirectory + '/train'
    valid_directory = SourceFileDirectory + '/valid'


    image_size = data_generation_parameters['image_size']
    data_num = data_generation_parameters['data_num']
    sample_num_train = data_generation_parameters['sample_num_train']
    sample_num_valid = data_generation_parameters['sample_num_valid']


    p = Pipeline_SIMdata_absorption_efficiency_pairs(source_directory=train_directory, output_directory=SaveFileDirectory+'/SIMdata_SR_train',image_size = image_size)
    p.sample(sample_num_train,multi_threaded=False,data_type='train', data_num=1)

